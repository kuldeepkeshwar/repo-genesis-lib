{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///external \"@babel/runtime/helpers/interopRequireDefault\"","webpack:///external \"@babel/runtime/regenerator\"","webpack:///external \"@babel/runtime/helpers/asyncToGenerator\"","webpack:///external \"@sindresorhus/is\"","webpack:///external \"tacker\"","webpack:///./src sync","webpack:///./src/index.js","webpack:///./src/parse.js","webpack:///external \"@babel/runtime/helpers/slicedToArray\"","webpack:///external \"fs-extra\"","webpack:///external \"path\"","webpack:///external \"chalk\"","webpack:///external \"paths-exist\"","webpack:///external \"get-pkg-prop\"","webpack:///./src/generate.js","webpack:///external \"@babel/runtime/helpers/asyncIterator\"","webpack:///external \"execa\""],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","require","webpackEmptyContext","req","e","Error","code","keys","resolve","id","oConfig","repoRemoteUri","symPath","repoPath","printMirror","log","console","mConfig","is","nullOrUndefined","chooseConfig","config","parseConfig","string","endsWith","myConfig","endsWidth","readConfig","cfg","printError","fn","msg","chalk","underline","undefined","rgConfigPath","process","env","repogenJsonPath","path","join","cwd","pathsExist","getPkgProp","repogenPkg","repogenJsPath","modernizeOldConfig","oOldConfig","oNewConfig","entries","k","v","rgAuthHost","assign","dir","repos","szPath","fs","readJson","configDir","rootDir","rgRootDir","repoRootDir","rgRepoRootDir","ensureDir","err","map","oRepository","length","parseNewRepoFormat","parseOldRepoFormat","repositories","szRootDir","plat","space","repo","sym","getTransformedConfig","szPlatform","oRepoKV","szSymlinkOptionalSubdir","szPlatformWorkspace","szRepositoryName","szSymlinkName","szWorkspace","szRepository","red","getRemoteUri","szNameOfSym","szOptionalSubdir","symlinkRootDir","getSymlinkPath","szNameOfRepo","getRepositoryPath","oWhat","szHow","genAll","genRepositories","genSymlinks","genDependencies","oWhatToGenerate","what","Promise","all","genRepository","genSymlink","genDependency","szRepoURIToClone","cloneRepository","getStringAfterChar","szString","szCharacter","substring","lastIndexOf","szRepoPath","szSymlinkPath","szWhereToInstall","szURI","arrURIs","cloneRes","uri"],"mappings":"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","file":"main.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 6);\n","module.exports = require(\"@babel/runtime/helpers/interopRequireDefault\");","module.exports = require(\"@babel/runtime/regenerator\");","module.exports = require(\"@babel/runtime/helpers/asyncToGenerator\");","module.exports = require(\"@sindresorhus/is\");","module.exports = require(\"tacker\");","function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = 5;","export {\n  parse,\n  chooseConfig,\n  parseConfig,\n  modernizeOldConfig,\n  readConfig\n} from \"./parse\";\n\nexport {\n  generate,\n  genAll,\n  genRepository,\n  genSymlink,\n  genDependency\n} from \"./generate\";\n","const log = console.log;\nimport fs from \"fs-extra\";\nimport path from \"path\";\nimport chalk from \"chalk\";\nimport is from \"@sindresorhus/is\";\nimport { pathsExist } from \"paths-exist\";\nimport { printError, printMirror } from \"tacker\";\nimport { getPkgProp } from \"get-pkg-prop\";\n\n//TODO: Create (or add) chooseConfig\nexport async function parse(mConfig) {\n  //TODO: Replace all ifs is() with 1 is call at top of fn and do simple str compare in ifs\n  if (is.nullOrUndefined(mConfig)) {\n    let config = await chooseConfig();\n    // printMirror({ config }, \"blue\", \"green\");\n    return parseConfig(config[0]);\n  } else if (is.string(mConfig)) {\n    if (mConfig.endsWith(\".json\") || myConfig.endsWidth(\".js\")) {\n      let cfg = await readConfig(mConfig);\n      // printMirror({ cfg }, \"cyan\", \"red\");\n      return parseConfig(cfg);\n    } else {\n      return printError(true, {\n        fn: \"parse\",\n        msg: `Unrecognized file type to parse. Expecting ${chalk.underline(\n          \".js\"\n        )} or ${chalk.underline(\".json\")}`\n      });\n    }\n  } else if (is.object(mConfig)) {\n    return parseConfig(mConfig);\n  } else {\n    printError(true, {\n      fn: \"parse\",\n      msg: \"Need to provide either a config object or path to a config file\"\n    });\n  }\n}\n\n//TODO: Debug this selecting .js instead of .json when both are present\nexport async function chooseConfig(oConfig = undefined) {\n  // let chosen;\n  //TODO: Remove first is.nullOrDefined check. Unnecessary\n  if (is.nullOrUndefined(oConfig)) {\n    const { rgConfigPath } = process.env; // => Set by CLI\n    const repogenJsonPath = path.join(process.cwd(), \".repogen.json\");\n    // printMirror({ repogenJsonPath }, \"red\", \"blue\");\n    if (is.nullOrUndefined(rgConfigPath)) {\n      // printMirror({ rgConfigPath }, \"red\", \"yellow\");\n      if ((await pathsExist(repogenJsonPath)) === false) {\n        // printMirror({ repogenJsonPath }, \"red\", \"yellow\");\n        let repogenPkg = await getPkgProp(\"repogen\");\n        printMirror({ repogenPkg }, \"yellow\", \"red\");\n        if ((await getPkgProp(\"repogen\")) === false) {\n          const repogenJsPath = path.join(process.cwd(), \".repogen.js\");\n          if (await pathsExist(repogenJsPath)) {\n            const { config } = require(repogenJsPath);\n            // printMirror({ config }, \"red\", \"yellow\");\n            // chosen = \"repogen.js in cwd\";\n            // printMirror({ chosen }, \"red\", \"yellow\");\n            return [modernizeOldConfig(config), \".repogen.js\"];\n          } else {\n            return printError({\n              fn: \"await pathsExist(repogenJsPath)\",\n              msg: \"Path didn't exist or there was an error with require()\"\n            });\n          }\n        } else {\n          // chosen = \"package.json in pkgUp\";\n          // printMirror({ chosen }, \"red\", \"yellow\");\n          return [await getPkgProp(\"repogen\"), \"package.json\"];\n        }\n      } else {\n        // printMirror({ repogenJsonPath }, \"red\", \"green\");\n        // chosen = \".repogen.json in cwd\";\n        // printMirror({ chosen }, \"red\", \"yellow\");\n        return [await readConfig(repogenJsonPath), \".repogen.json\"];\n      }\n    } else {\n      // printMirror({ rgConfigPath }, \"red\", \"green\");\n      // chosen = \"custom config at specified path\";\n      // printMirror({ chosen }, \"red\", \"yellow\");\n      return [await readConfig(rgConfigPath), rgConfigPath];\n    }\n  } else {\n    //TODO: Also unnecessary... Unless chooseConfig is being used on its own\n    if (oConfig.hasOwnProperty(\"repositories\")) {\n      // chosen = \"passed repogen.js style config\";\n      // printMirror({ chosen }, \"red\", \"yellow\");\n      // printMirror({ oConfig }, \"red\", \"blue\");\n      return [modernizeOldConfig(oConfig), \".repogen.js\"];\n    } else {\n      // chosen = \"passed .repogen.json style config\";\n      // printMirror({ chosen }, \"red\", \"yellow\");\n      return [oConfig, \".repogen.json\"];\n    }\n  }\n}\n\nexport function modernizeOldConfig(oOldConfig) {\n  let oNewConfig = {};\n  for (let [k, v] of Object.entries(oOldConfig)) {\n    if (k === \"provider\") {\n      process.env.rgAuthHost = v;\n    }\n    if (k === \"repospacePath\") {\n      Object.assign(oNewConfig, { dir: v });\n    }\n    if (k === \"repositories\") {\n      Object.assign(oNewConfig, { repos: v });\n    }\n  }\n  if (oNewConfig.hasOwnProperty(\"dir\") === false) {\n    Object.assign(oNewConfig, { dir: \"\" });\n  }\n  return oNewConfig;\n}\n\nexport async function readConfig(szPath) {\n  //TODO: Enable .repogen.json --> monolith libs (ie. \"container\" monolith)\n  //TODO: Enable .repogen.js --> backwards compatability\n  //TODO: Enable package.json --> disadvantage being requires npm; useful only for packages\n  if (await pathsExist(szPath)) {\n    if (szPath.endsWith(\".json\")) {\n      return await fs.readJson(szPath);\n    } else if (szPath.endsWith(\".js\")) {\n      const { config } = require(szPath);\n      if (is.nullOrUndefined(config)) {\n        return printError(true, {\n          fn: \"readConfig()->require()\",\n          msg: \"Does your repogen.js config export a config object?\"\n        });\n      } else {\n        return config;\n      }\n    }\n  } else {\n    return printError(true, {\n      fn: \"readConfig()\",\n      msg: `Specified config file path doesn't exist:\\n ${chalk.underline(\n        szPath\n      )}`\n    });\n  }\n}\n\n//TODO: Try to set process.env.rgAuthHost\n// - .repogen.js: \"provider\"\n// - .repogen.json: \"provider\"\n// - .package.json: \"provider\"\n// - directly via CLI flag (ie. options)\n\n/*\nTODO: Create a helper function to abstract the below\n*  let cloneRemoteString = getRemoteString(\"github.com\", space, repo);\n*  let symlinkPath = getSymlinkPath(repo)\n*  let repositoryPath = getSymlinkPath(repo)\n*/\n\nexport function parseConfig(oConfig) {\n  if (is.nullOrUndefined(oConfig)) {\n    return null;\n  } else {\n    if (oConfig.hasOwnProperty(\"dir\")) {\n      var configDir = oConfig.dir;\n    } else {\n      configDir = \".\";\n    }\n  }\n  let rootDir = path.join(process.cwd(), configDir);\n  process.env.rgRootDir = rootDir;\n  // printMirror({ rootDir }, \"magenta\", \"grey\");\n  let repoRootDir = path.join(rootDir, \".repositories\");\n  process.env.rgRepoRootDir = repoRootDir;\n  //TODO: Move ensureDirectory to parseXRepoFormat\n  (async () => {\n    await fs.ensureDir(repoRootDir).catch(err =>\n      printError(true, {\n        fn: \"parseConfig -> await fs.ensureDir\",\n        err,\n        msg: \"Directory could not be corrected\"\n      })\n    );\n  })();\n  if (oConfig.hasOwnProperty(\"repos\")) {\n    return oConfig.repos.map(oRepository => {\n      if (Object.keys(oRepository).length > 1) {\n        return parseNewRepoFormat(oRepository, rootDir);\n      } else {\n        // printMirror({ oRepository }, \"cyan\", \"yellow\");\n        return parseOldRepoFormat(\"github.com\", oRepository, rootDir);\n      }\n    });\n  } else if (oConfig.hasOwnProperty(\"repositories\")) {\n    return oConfig.repositories.map(oRepository => {\n      // printMirror({ oRepository }, \"cyan\", \"green\");\n      return parseOldRepoFormat(\"github.com\", oRepository, rootDir);\n    });\n  }\n}\nexport function parseNewRepoFormat(oRepository, szRootDir) {\n  if (is.nullOrUndefined(oRepository) || is.nullOrUndefined(szRootDir)) {\n    return null;\n  }\n  //TODO: Refactor test to address lack of Object.keys(oRepository).length > 1 check\n  const {\n    plat = \"github.com\",\n    space,\n    repo,\n    dir = \"\",\n    sym = repo\n  } = oRepository;\n  if (is.nullOrUndefined(space) || is.nullOrUndefined(repo)) {\n    return null;\n  }\n  if (Object.keys(oRepository).length > 1) {\n    return getTransformedConfig(plat, space, repo, szRootDir, dir, sym);\n  } else {\n    printError(true, {\n      fn: \"parseNewRepoFormat\",\n      msg: \"parseNewRepoFormat was called against an old repo format\"\n    });\n  }\n}\nexport function parseOldRepoFormat(\n  szPlatform = \"github.com\",\n  oRepoKV,\n  szRootDir,\n  szSymlinkOptionalSubdir = \"\"\n) {\n  if (is.nullOrUndefined(oRepoKV) || is.nullOrUndefined(szRootDir)) {\n    return null;\n  }\n  let space = Object.keys(oRepoKV);\n  let repo = oRepoKV[space];\n  return getTransformedConfig(\n    szPlatform,\n    space,\n    repo,\n    szRootDir,\n    szSymlinkOptionalSubdir,\n    repo\n  );\n}\n\nexport function printTransformedConfig(oConfig) {\n  const { repoRemoteUri, symPath, repoPath } = oConfig;\n  printMirror({ repoRemoteUri }, \"magenta\", \"grey\");\n  printMirror({ symPath }, \"magenta\", \"grey\");\n  printMirror({ repoPath }, \"magenta\", \"grey\");\n}\nexport function getTransformedConfig(\n  szPlatform = \"github.com\",\n  szPlatformWorkspace,\n  szRepositoryName,\n  szRootDir,\n  szSymlinkOptionalSubdir = \"\",\n  szSymlinkName = szRepositoryName\n) {\n  //TODO: Add null params\n  //TODO: Add null param test\n  let repoRemoteUri = getRemoteUri(\n    szPlatform,\n    szPlatformWorkspace,\n    szRepositoryName\n  );\n  let symPath = getSymlinkPath(\n    szSymlinkName,\n    szRootDir,\n    szSymlinkOptionalSubdir\n  );\n  let repoPath = getRepositoryPath(szRootDir, szRepositoryName);\n  return {\n    repoRemoteUri,\n    symPath,\n    repoPath\n  };\n}\nfunction getRemoteUri(szPlatform, szWorkspace, szRepository) {\n  if (\n    is.nullOrUndefined(szPlatform) ||\n    is.nullOrUndefined(szWorkspace) ||\n    is.nullOrUndefined(szRepository)\n  )\n    log(`process.env.rgAuthHost: ${chalk.red(process.env.rgAuthHost)}`);\n  if (is.nullOrUndefined(process.env.rgAuthHost)) {\n    let repoUri = `https://${szPlatform}/${szWorkspace}/${szRepository}`;\n    // printMirror({ repoUri }, \"magenta\", \"blue\");\n    return repoUri;\n  } else {\n    let repoUri = `git@${\n      process.env.rgAuthHost\n    }:${szWorkspace}/${szRepository}`;\n    // printMirror({ repoUri }, \"magenta\", \"green\");\n    return repoUri;\n  }\n}\n//TODO: Debug; currently not prepending sandbox from config.dir\n/*\nconfigFromParseConfig: [\n  {\n    \"repoRemoteUri\": \"git@alechp:servexyz/get-pkg-prop\",\n    \"symPath\": \"/Users/alechp/Code/servexyz/genesis/.repositories/repo-genesis/.repositories/repo-genesis-lib/modules/gpp\",\n    \"repoPath\": \"/Users/alechp/Code/servexyz/genesis/.repositories/repo-genesis/.repositories/repo-genesis-lib/.repositories/get-pkg-prop\"\n  },\n  {\n    \"repoRemoteUri\": \"git@alechp:servexyz/tacker\",\n    \"symPath\": \"/Users/alechp/Code/servexyz/genesis/.repositories/repo-genesis/.repositories/repo-genesis-lib/tkr\",\n    \"repoPath\": \"/Users/alechp/Code/servexyz/genesis/.repositories/repo-genesis/.repositories/repo-genesis-lib/.repositories/tacker\"\n  },\n  {\n    \"repoRemoteUri\": \"git@alechp:servexyz/paths-exist\",\n    \"symPath\": \"/Users/alechp/Code/servexyz/genesis/.repositories/repo-genesis/.repositories/repo-genesis-lib/paths-exist\",\n    \"repoPath\": \"/Users/alechp/Code/servexyz/genesis/.repositories/repo-genesis/.repositories/repo-genesis-lib/.repositories/paths-exist\"\n  }\n]\n*/\nfunction getSymlinkPath(szNameOfSym, szRootDir, szOptionalSubdir = \"\") {\n  if (is.nullOrUndefined(szNameOfSym)) return null;\n  let symlinkRootDir = path.join(szRootDir, szOptionalSubdir);\n  (async () => {\n    await fs.ensureDir(symlinkRootDir).catch(err =>\n      printError(true, {\n        fn: \"getSymlinkPath -> await fs.ensureDir\",\n        err,\n        msg: \"Directory could not be created\"\n      })\n    );\n  })();\n  let joinedSymlinkPath = path.join(symlinkRootDir, szNameOfSym);\n  return joinedSymlinkPath;\n}\n\n//TODO: Debug; currently not prepending sandbox from config.dir\nfunction getRepositoryPath(szRootDir, szNameOfRepo) {\n  if (is.nullOrUndefined(szNameOfRepo)) return null;\n  let repositoriesPath = path.join(szRootDir, \".repositories\", szNameOfRepo);\n  return repositoriesPath;\n}\n","module.exports = require(\"@babel/runtime/helpers/slicedToArray\");","module.exports = require(\"fs-extra\");","module.exports = require(\"path\");","module.exports = require(\"chalk\");","module.exports = require(\"paths-exist\");","module.exports = require(\"get-pkg-prop\");","const log = console.log;\nimport execa from \"execa\";\nimport { printMirror, printLine } from \"tacker\";\nimport is from \"@sindresorhus/is\";\n\nexport async function generate(oWhat, szHow) {\n  try {\n    switch (szHow) {\n      case \"all\":\n        return await genAll(oWhat);\n      case \"repositories\":\n        return await genRepositories(oWhat);\n      case \"symlinks\":\n        return await genSymlinks(oWhat);\n      case \"dependencies\":\n        return await genDependencies(oWhat);\n    }\n  } catch (e) {\n    return new Error(e);\n  }\n}\nexport async function genAll(oWhatToGenerate) {\n  try {\n    for await (let what of oWhatToGenerate) {\n      let { repoRemoteUri, symPath, repoPath } = what;\n      await Promise.all([\n        genRepository(repoRemoteUri),\n        genSymlink(repoPath, symPath),\n        genDependency(repoPath)\n      ]);\n    }\n    return true;\n  } catch (e) {\n    return new Error(e);\n  }\n}\nexport async function genRepository(szRepoURIToClone) {\n  // printMirror({ szRepoURIToClone }, \"red\", \"grey\");\n  try {\n    await cloneRepository(szRepoURIToClone);\n  } catch (e) {\n    return new Error(e);\n  }\n}\nfunction getStringAfterChar(szString, szCharacter) {\n  return szString.substring(\n    szString.lastIndexOf(szCharacter) + 1,\n    szString.length\n  );\n}\nexport async function genSymlink(szRepoPath, szSymlinkPath) {\n  if (is.nullOrUndefined(szSymlinkPath)) {\n    var name = getStringAfterChar(szRepoPath, \"/\");\n  } else {\n    name = getStringAfterChar(szSymlinkPath, \"/\");\n  }\n  try {\n    await execa(\"ln\", [\"-s\", szRepoPath, szSymlinkPath]);\n  } catch (e) {\n    return new Error(e);\n  }\n}\nexport async function genDependency(szWhereToInstall) {\n  //TODO: Add option to allow choosing package manager (npm, yarn, etc)\n  try {\n    await execa(\"npm\", [\"install\"], { cwd: szWhereToInstall });\n    return true;\n  } catch (e) {\n    return new Error(e);\n  }\n}\n\n//TODO: async function genRepositories(oWhatToGenerate) {}\n//TODO: async function genSymlinks(oWhatToGenerate) {}\n//TODO: async function genDependencies(oWhatToGenerate) {}\n\nasync function cloneRepository(szURI) {\n  return await execa(\"git\", [\"clone\", szURI], {\n    cwd: process.env.rgRepoRootDir\n  });\n}\nexport async function cloneRepositories(arrURIs) {\n  // [ { uri, sym, dir }, { uri, sym, dir }]\n  //TODO: Ensure .repositories directory\n  let cloneRes = {};\n  for await (let uri of arrURIs) {\n    try {\n      await cloneRepository(uri);\n      Object.assign(cloneRes, { uri: true });\n    } catch (e) {\n      Object.assign(cloneRes, { uri: [false, e] });\n    }\n  }\n}\n","module.exports = require(\"@babel/runtime/helpers/asyncIterator\");","module.exports = require(\"execa\");"],"sourceRoot":""}